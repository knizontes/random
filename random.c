/*
 * random.c -- A strong random number generator
 *
 * Copyright Matt Mackall <mpm@selenic.com>, 2003, 2004, 2005
 *
 * Copyright Theodore Ts'o, 1994, 1995, 1996, 1997, 1998, 1999.  All
 * rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, and the entire permission notice in its entirety,
 *    including the disclaimer of warranties.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior
 *    written permission.
 *
 * ALTERNATIVELY, this product may be distributed under the terms of
 * the GNU General Public License, in which case the provisions of the GPL are
 * required INSTEAD OF the above restrictions.  (This clause is
 * necessary due to a potential bad interaction between the GPL and
 * the restrictions contained in a BSD-style copyright.)
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
 * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 */

/*
 * (now, with legal B.S. out of the way.....)
 *
 * This routine gathers environmental noise from device drivers, etc.,
 * and returns good random numbers, suitable for cryptographic use.
 * Besides the obvious cryptographic uses, these numbers are also good
 * for seeding TCP sequence numbers, and other places where it is
 * desirable to have numbers which are not only random, but hard to
 * predict by an attacker.
 *
 * Theory of operation
 * ===================
 *
 * Computers are very predictable devices.  Hence it is extremely hard
 * to produce truly random numbers on a computer --- as opposed to
 * pseudo-random numbers, which can easily generated by using a
 * algorithm.  Unfortunately, it is very easy for attackers to guess
 * the sequence of pseudo-random number generators, and for some
 * applications this is not acceptable.  So instead, we must try to
 * gather "environmental noise" from the computer's environment, which
 * must be hard for outside attackers to observe, and use that to
 * generate random numbers.  In a Unix environment, this is best done
 * from inside the kernel.
 *
 * Sources of randomness from the environment include inter-keyboard
 * timings, inter-interrupt timings from some interrupts, and other
 * events which are both (a) non-deterministic and (b) hard for an
 * outside observer to measure.  Randomness from these sources are
 * added to an "entropy pool", which is mixed using a CRC-like function.
 * This is not cryptographically strong, but it is adequate assuming
 * the randomness is not chosen maliciously, and it is fast enough that
 * the overhead of doing it on every interrupt is very reasonable.
 * As random bytes are mixed into the entropy pool, the routines keep
 * an *estimate* of how many bits of randomness have been stored into
 * the random number generator's internal state.
 *
 * When random bytes are desired, they are obtained by taking the SHA
 * hash of the contents of the "entropy pool".  The SHA hash avoids
 * exposing the internal state of the entropy pool.  It is believed to
 * be computationally infeasible to derive any useful information
 * about the input of SHA from its output.  Even if it is possible to
 * analyze SHA in some clever way, as long as the amount of data
 * returned from the generator is less than the inherent entropy in
 * the pool, the output data is totally unpredictable.  For this
 * reason, the routine decreases its internal estimate of how many
 * bits of "true randomness" are contained in the entropy pool as it
 * outputs random numbers.
 *
 * If this estimate goes to zero, the routine can still generate
 * random numbers; however, an attacker may (at least in theory) be
 * able to infer the future output of the generator from prior
 * outputs.  This requires successful cryptanalysis of SHA, which is
 * not believed to be feasible, but there is a remote possibility.
 * Nonetheless, these numbers should be useful for the vast majority
 * of purposes.
 *
 * Exported interfaces ---- output
 * ===============================
 *
 * There are three exported interfaces; the first is one designed to
 * be used from within the kernel:
 *
 * 	void get_random_bytes(void *buf, int nbytes);
 *
 * This interface will return the requested number of random bytes,
 * and place it in the requested buffer.
 *
 * The two other interfaces are two character devices /dev/random and
 * /dev/urandom.  /dev/random is suitable for use when very high
 * quality randomness is desired (for example, for key generation or
 * one-time pads), as it will only return a maximum of the number of
 * bits of randomness (as estimated by the random number generator)
 * contained in the entropy pool.
 *
 * The /dev/urandom device does not have this limit, and will return
 * as many bytes as are requested.  As more and more random bytes are
 * requested without giving time for the entropy pool to recharge,
 * this will result in random numbers that are merely cryptographically
 * strong.  For many applications, however, this is acceptable.
 *
 * Exported interfaces ---- input
 * ==============================
 *
 * The current exported interfaces for gathering environmental noise
 * from the devices are:
 *
 *	void add_device_randomness(const void *buf, unsigned int size);
 * 	void add_input_randomness(unsigned int type, unsigned int code,
 *                                unsigned int value);
 *	void add_interrupt_randomness(int irq, int irq_flags);
 * 	void add_disk_randomness(struct gendisk *disk);
 *
 * add_device_randomness() is for adding data to the random pool that
 * is likely to differ between two devices (or possibly even per boot).
 * This would be things like MAC addresses or serial numbers, or the
 * read-out of the RTC. This does *not* add any actual entropy to the
 * pool, but it initializes the pool to different values for devices
 * that might otherwise be identical and have very little entropy
 * available to them (particularly common in the embedded world).
 *
 * add_input_randomness() uses the input layer interrupt timing, as well as
 * the event type information from the hardware.
 *
 * add_interrupt_randomness() uses the interrupt timing as random
 * inputs to the entropy pool. Using the cycle counters and the irq source
 * as inputs, it feeds the randomness roughly once a second.
 *
 * add_disk_randomness() uses what amounts to the seek time of block
 * layer request events, on a per-disk_devt basis, as input to the
 * entropy pool. Note that high-speed solid state drives with very low
 * seek times do not make for good sources of entropy, as their seek
 * times are usually fairly consistent.
 *
 * All of these routines try to estimate how many bits of randomness a
 * particular randomness source.  They do this by keeping track of the
 * first and second order deltas of the event timings.
 *
 * Ensuring unpredictability at system startup
 * ============================================
 *
 * When any operating system starts up, it will go through a sequence
 * of actions that are fairly predictable by an adversary, especially
 * if the start-up does not involve interaction with a human operator.
 * This reduces the actual number of bits of unpredictability in the
 * entropy pool below the value in entropy_count.  In order to
 * counteract this effect, it helps to carry information in the
 * entropy pool across shut-downs and start-ups.  To do this, put the
 * following lines an appropriate script which is run during the boot
 * sequence:
 *
 *	echo "Initializing random number generator..."
 *	random_seed=/var/run/random-seed
 *	# Carry a random seed from start-up to start-up
 *	# Load and then save the whole entropy pool
 *	if [ -f $random_seed ]; then
 *		cat $random_seed >/dev/urandom
 *	else
 *		touch $random_seed
 *	fi
 *	chmod 600 $random_seed
 *	dd if=/dev/urandom of=$random_seed count=1 bs=512
 *
 * and the following lines in an appropriate script which is run as
 * the system is shutdown:
 *
 *	# Carry a random seed from shut-down to start-up
 *	# Save the whole entropy pool
 *	echo "Saving random seed..."
 *	random_seed=/var/run/random-seed
 *	touch $random_seed
 *	chmod 600 $random_seed
 *	dd if=/dev/urandom of=$random_seed count=1 bs=512
 *
 * For example, on most modern systems using the System V init
 * scripts, such code fragments would be found in
 * /etc/rc.d/init.d/random.  On older Linux systems, the correct script
 * location might be in /etc/rcb.d/rc.local or /etc/rc.d/rc.0.
 *
 * Effectively, these commands cause the contents of the entropy pool
 * to be saved at shut-down time and reloaded into the entropy pool at
 * start-up.  (The 'dd' in the addition to the bootup script is to
 * make sure that /etc/random-seed is different for every start-up,
 * even if the system crashes without executing rc.0.)  Even with
 * complete knowledge of the start-up activities, predicting the state
 * of the entropy pool requires knowledge of the previous history of
 * the system.
 *
 * Configuring the /dev/random driver under Linux
 * ==============================================
 *
 * The /dev/random driver under Linux uses minor numbers 8 and 9 of
 * the /dev/mem major number (#1).  So if your system does not have
 * /dev/random and /dev/urandom created already, they can be created
 * by using the commands:
 *
 * 	mknod /dev/random c 1 8
 * 	mknod /dev/urandom c 1 9
 *
 * Acknowledgements:
 * =================
 *
 * Ideas for constructing this random number generator were derived
 * from Pretty Good Privacy's random number generator, and from private
 * discussions with Phil Karn.  Colin Plumb provided a faster random
 * number generator, which speed up the mixing function of the entropy
 * pool, taken from PGPfone.  Dale Worley has also contributed many
 * useful ideas and suggestions to improve this driver.
 *
 * Any flaws in the design are solely my responsibility, and should
 * not be attributed to the Phil, Colin, or any of authors of PGP.
 *
 * Further background information on this topic may be obtained from
 * RFC 1750, "Randomness Recommendations for Security", by Donald
 * Eastlake, Steve Crocker, and Jeff Schiller.
 */

#include <linux/utsname.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/major.h>
#include <linux/string.h>
#include <linux/fcntl.h>
#include <linux/slab.h>
#include <linux/random.h>
#include <linux/poll.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/genhd.h>
#include <linux/interrupt.h>
#include <linux/mm.h>
#include <linux/spinlock.h>
#include <linux/percpu.h>
#include <linux/cryptohash.h>
#include <linux/fips.h>
#include <linux/ptrace.h>
#include <linux/kmemcheck.h>
#include <linux/workqueue.h>
#include <linux/irq.h>

#include <asm/processor.h>
#include <asm/uaccess.h>
#include <asm/irq.h>
#include <asm/irq_regs.h>
#include <asm/io.h>

#define CREATE_TRACE_POINTS
#include <trace/events/random.h>

/*
 * Configuration information
 */
#define INPUT_POOL_SHIFT	12
#define INPUT_POOL_WORDS	(1 << (INPUT_POOL_SHIFT-5))
#define OUTPUT_POOL_SHIFT	10
/*
 * parole di cui è costituito il buffer in output (credo quindi valga per le pool secondarie).
 * In totale 2^5 = 32
 */
#define OUTPUT_POOL_WORDS	(1 << (OUTPUT_POOL_SHIFT-5))
/*
 * trasferimento di bytes possibile dalla pool secondaria
 * Credo non una qualunque, ma dalla blocking
 * per evitare il prosciugamento di entropia.
 * Infatti appare solo in random read
 */
#define SEC_XFER_SIZE		512
#define EXTRACT_SIZE		10

#define DEBUG_RANDOM_BOOT 0


/*
 *  the number of ulong if
 */
#define LONGS(x) (((x) + sizeof(unsigned long) - 1)/sizeof(unsigned long))

/*
 * To allow fractional bits to be tracked, the entropy_count field is
 * denominated in units of 1/8th bits.
 *
 * 2*(ENTROPY_SHIFT + log2(poolbits)) must <= 31, or the multiply in
 * credit_entropy_bits() needs to be 64 bits wide.
 */
#define ENTROPY_SHIFT 3
#define ENTROPY_BITS(r) ((r)->entropy_count >> ENTROPY_SHIFT)

/*
 * The minimum number of bits of entropy before we wake up a read on
 * /dev/random.  Should be enough to do a significant reseed.
 */
static int random_read_wakeup_thresh = 64;

/*
 * If the entropy count falls under this number of bits, then we
 * should wake up processes which are selecting or polling on write
 * access to /dev/random.
 */
static int random_write_wakeup_thresh = 28 * OUTPUT_POOL_WORDS;

/*
 * The minimum number of seconds between urandom pool resending.  We
 * do this to limit the amount of entropy that can be drained from the
 * input pool even if there are heavy demands on /dev/urandom.
 */
static int random_min_urandom_seed = 60;

/*
 * Originally, we used a primitive polynomial of degree .poolwords
 * over GF(2).  The taps for various sizes are defined below.  They
 * were chosen to be evenly spaced except for the last tap, which is 1
 * to get the twisting happening as fast as possible.
 *
 * For the purposes of better mixing, we use the CRC-32 polynomial as
 * well to make a (modified) twisted Generalized Feedback Shift
 * Register.  (See M. Matsumoto & Y. Kurita, 1992.  Twisted GFSR
 * generators.  ACM Transactions on Modeling and Computer Simulation
 * 2(3):179-194.  Also see M. Matsumoto & Y. Kurita, 1994.  Twisted
 * GFSR generators II.  ACM Transactions on Mdeling and Computer
 * Simulation 4:254-266)
 *
 * Thanks to Colin Plumb for suggesting this.
 *
 * The mixing operation is much less sensitive than the output hash,
 * where we use SHA-1.  All that we want of mixing operation is that
 * it be a good non-cryptographic hash; i.e. it not produce collisions
 * when fed "random" data of the sort we expect to see.  As long as
 * the pool state differs for different inputs, we have preserved the
 * input entropy and done a good job.  The fact that an intelligent
 * attacker can construct inputs that will produce controlled
 * alterations to the pool's state is not important because we don't
 * consider such inputs to contribute any randomness.  The only
 * property we need with respect to them is that the attacker can't
 * increase his/her knowledge of the pool's state.  Since all
 * additions are reversible (knowing the final state and the input,
 * you can reconstruct the initial state), if an attacker has any
 * uncertainty about the initial state, he/she can only shuffle that
 * uncertainty about, but never cause any collisions (which would
 * decrease the uncertainty).
 *
 * Our mixing functions were analyzed by Lacharme, Roeck, Strubel, and
 * Videau in their paper, "The Linux Pseudorandom Number Generator
 * Revisited" (see: http://eprint.iacr.org/2012/251.pdf).  In their
 * paper, they point out that we are not using a true Twisted GFSR,
 * since Matsumoto & Kurita used a trinomial feedback polynomial (that
 * is, with only three taps, instead of the six that we are using).
 * As a result, the resulting polynomial is neither primitive nor
 * irreducible, and hence does not have a maximal period over
 * GF(2**32).  They suggest a slight change to the generator
 * polynomial which improves the resulting TGFSR polynomial to be
 * irreducible, which we have made here.
 */
static struct poolinfo {
	/*	 *
	 * poolfracbits rappresenta il numero di frazionali di bit, di dimensione
	 * 2^(-ENTROPY_SHIFT), di cui è composta la pool.
	 *
	 * x<<5 è il numero di bit interi della pool, ovvero il numero di parole della pool
	 * moltiplicato per 32 bit- 4 byte
	 *
	 * ENTROPY_SHIFT rappresenta quindi il numero di "decimali" contemplati dall'entropy counter(sembra
	 * servano particolarmente per evitare l'arrotondamento a zero -esistente prima del'introduzione di pool_frac_bits- durante
	 * l'accredito di bit di entropia presso entropy_counter)
	 *
	 * poolfracbits è considerata come la domensione in bit della pool
	 */
	int poolbitshift, poolwords, poolbytes, poolbits, poolfracbits;
#define S(x) ilog2(x)+5, (x), (x)*4, (x)*32, (x) << (ENTROPY_SHIFT+5)
	int tap1, tap2, tap3, tap4, tap5;
} poolinfo_table[] = {
	/*
	 * poolbitshift = 7 (il log di 128) + 5
	 * poolwords = 128
	 * poolbytes = 512 (128*4) ---> parole da 4 bytes = 32 bits
	 * poolbits = 4096 (poolbytes*8)
	 * poolfracbits = 128* 2^8 
	 */
	/* was: x^128 + x^103 + x^76 + x^51 +x^25 + x + 1 */
	/* x^128 + x^104 + x^76 + x^51 +x^25 + x + 1 */
	{ S(128),	104,	76,	51,	25,	1 },
	/* was: x^32 + x^26 + x^20 + x^14 + x^7 + x + 1 */
	/* x^32 + x^26 + x^19 + x^14 + x^7 + x + 1 */
	{ S(32),	26,	19,	14,	7,	1 },
#if 0
	/* x^2048 + x^1638 + x^1231 + x^819 + x^411 + x + 1  -- 115 */
	{ S(2048),	1638,	1231,	819,	411,	1 },

	/* x^1024 + x^817 + x^615 + x^412 + x^204 + x + 1 -- 290 */
	{ S(1024),	817,	615,	412,	204,	1 },

	/* x^1024 + x^819 + x^616 + x^410 + x^207 + x^2 + 1 -- 115 */
	{ S(1024),	819,	616,	410,	207,	2 },

	/* x^512 + x^411 + x^308 + x^208 + x^104 + x + 1 -- 225 */
	{ S(512),	411,	308,	208,	104,	1 },

	/* x^512 + x^409 + x^307 + x^206 + x^102 + x^2 + 1 -- 95 */
	{ S(512),	409,	307,	206,	102,	2 },
	/* x^512 + x^409 + x^309 + x^205 + x^103 + x^2 + 1 -- 95 */
	{ S(512),	409,	309,	205,	103,	2 },

	/* x^256 + x^205 + x^155 + x^101 + x^52 + x + 1 -- 125 */
	{ S(256),	205,	155,	101,	52,	1 },

	/* x^128 + x^103 + x^78 + x^51 + x^27 + x^2 + 1 -- 70 */
	{ S(128),	103,	78,	51,	27,	2 },

	/* x^64 + x^52 + x^39 + x^26 + x^14 + x + 1 -- 15 */
	{ S(64),	52,	39,	26,	14,	1 },
#endif
};

/*
 * Static global variables
 */
static DECLARE_WAIT_QUEUE_HEAD(random_read_wait);
static DECLARE_WAIT_QUEUE_HEAD(random_write_wait);
static struct fasync_struct *fasync;

/**********************************************************************
 *
 * OS independent entropy store.   Here are the functions which handle
 * storing entropy in an entropy pool.
 *
 **********************************************************************/

/*
 * UN'entropy store contiene i dati, puntatori e funzioni di una specifica pool.
 * Modella l'intera pool
 */
struct entropy_store;
struct entropy_store {
	//------------------------------------------------------------
	/* read-only data: */
	//il polinomio della pool e le informazioni poolinfo
	const struct poolinfo *poolinfo;
	//Il puntatore allo stato interno della pool
	__u32 *pool;
	//Il nome della pool
	const char *name;
	/* punta alla input pool nel caso l'entropy store faccia riferimento alla pool blocking o a urandom*/
	struct entropy_store *pull;
	/* Le pool di output inizializzano questo campo come puntatore alla funzione push_to_pool, la input pool non lo inizializza */

	struct work_struct push_work;
	//------------------------------------------------------------
	
	/* read-write data: */
	/* l'ultimo istante in jiffies in cui sono stati estratti bytes dalla pool	 */
	unsigned long last_pulled;
	spinlock_t lock;
	/* puntatore ciclico alla prossima parola della pool da trattare per le funzioni di mixing. Le parole vengono
	 * lette in ordine inverso rispetto all'ordine nel buffer. Inizializzata a 0 (default)*/
	unsigned short add_ptr;
	/* numero di posizioni per cui devono essere ruotati i bit della prossima parola di entropia da aggiungere alla pool.
	 * Viene incrementato di sette posizioni per volta per accesso. Il primo incremento
	 * è pari a 14 posizioni. */
	unsigned short input_rotate;
	/* contatore dei bit di entropia, contato come #bit * 2^3 (considera quindi anche gli ottavi di bit)	 */
	int entropy_count;
	/* contiene il numero intero di bits di entropia */
	int entropy_total;
	unsigned int initialized:1;
	/* variabile di un bit, di fatto un booleano: se pari a 1, la pool è bloccante*/
	unsigned int limit:1;
	// non usati - presenti solo in sezioni codice "spente"
	unsigned int last_data_init:1;
	__u8 last_data[EXTRACT_SIZE];
};

static void push_to_pool(struct work_struct *work);
/*
 * Gli stati interni delle tre pool
 */
static __u32 input_pool_data[INPUT_POOL_WORDS];
static __u32 blocking_pool_data[OUTPUT_POOL_WORDS];
static __u32 nonblocking_pool_data[OUTPUT_POOL_WORDS];


/*
 * Inizializzazione della input
 * Limit inizializzato a 1 (blocking pool)
 */
static struct entropy_store input_pool = {
	.poolinfo = &poolinfo_table[0],
	.name = "input",
	.limit = 1,
	.lock = __SPIN_LOCK_UNLOCKED(input_pool.lock),
	.pool = input_pool_data
};

/*
 * Inizializzazione della blocking (/dev/random)
 * Limit inizializzato a 1 (blocking pool)
 */

static struct entropy_store blocking_pool = {
	.poolinfo = &poolinfo_table[1],
	.name = "blocking",
	.limit = 1,
	.pull = &input_pool,
	.lock = __SPIN_LOCK_UNLOCKED(blocking_pool.lock),
	.pool = blocking_pool_data,
	.push_work = __WORK_INITIALIZER(blocking_pool.push_work,
					push_to_pool),
};

/*
 * Inizializzazione della pool /dev/urandom
 * Notare che non viene inizializzato limit, default a 0
 */
static struct entropy_store nonblocking_pool = {
	.poolinfo = &poolinfo_table[1],
	.name = "nonblocking",
	.pull = &input_pool,
	.lock = __SPIN_LOCK_UNLOCKED(nonblocking_pool.lock),
	.pool = nonblocking_pool_data,
	.push_work = __WORK_INITIALIZER(nonblocking_pool.push_work,
					push_to_pool),
};

//CAPIRE
static __u32 const twist_table[8] = {
	0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
	0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278 };

/*
 * This function adds bytes into the entropy "pool".  It does not
 * update the entropy estimate.  The caller should call
 * credit_entropy_bits if this is appropriate.
 *
 * The pool is stirred with a primitive polynomial of the appropriate
 * degree, and then twisted.  We twist by three bits at a time because
 * it's cheap to do so and helps slightly in the expected case where
 * the entropy is concentrated in the low-order bits.
 */
static void _mix_pool_bytes(struct entropy_store *r, const void *in,
			    int nbytes, __u8 out[64])
{
	unsigned long i, j, tap1, tap2, tap3, tap4, tap5;
	int input_rotate;
	/*
	 * wordmask è il numero di parole della pool -1
	 * 127 per la input pool
	 * 31 per le secondarie
	 *
	 * bytes punta al buffer di bytes da mischiare (in)
	 * w è una parola di 4 bytes
	 */
	int wordmask = r->poolinfo->poolwords - 1;
	
	const char *bytes = in;
	__u32 w;

	/*
	 * I tap contengono le potenze dei polinomi, escluso x^0 che è sempre presente
	 */
	tap1 = r->poolinfo->tap1;
	tap2 = r->poolinfo->tap2;
	tap3 = r->poolinfo->tap3;
	tap4 = r->poolinfo->tap4;
	tap5 = r->poolinfo->tap5;

	/*
	 * solo una barrier
	 */
	smp_rmb();
	/*
	 * input_rotate e add_ptr sono inizializzati come default (0).
	 */
	input_rotate = ACCESS_ONCE(r->input_rotate);
	i = ACCESS_ONCE(r->add_ptr);

	/* mix one byte at a time to simplify size handling and churn faster */
	while (nbytes--) {
		/*
		 * rol32 ruota un valore di 32 bit a sinistra
		 * viene preso un byte per volta dei primi nbytes del buffer.
		 * Il puntatore al buffer, bytes, viene incrementato di un byte per volta, spostando così in avanti
		 * la locazione da scrivere.
		 *
		 * Poiché bytes è un puntatore a char, ogni byte viene preso considerato con i tre bytes successivi 
		 * per essere poi ruotato di input rotate e salvato in w.
		 * 
		 * Ogni byte viene quindi considerato da uno (il primo byte) fino a 4 volte (è necessario quindi che 
		 * nbytes <= len(bytes) -4 )
		 * 
		 * w è un intero a 32 bit (4B)
		 * w contiene quindi un intero di 4 bytes pari al byte random ruotato di input_rotate posizioni a sistra.
		 
		  		static inline __u32 rol32(__u32 word, unsigned int shift){
					return (word << shift) | (word >> (32 - shift));
				}
		 *
		 */
		w = rol32(*bytes++, input_rotate);

		/*
		 * wordmask è unica per la pool primaria e uguale per le due secondarie.
		 * siccome wordmask è composto da tutti 1 (in quanto è pari al numero di parole della pool che è una
		 * potenza di 2 -1), in i viene assegnato un valore pari al vecchio i - 1 in and con la wordmask,
		 * ovvero con i primi log2(numero di parole)-1.
		 *
		 *  i viene usato per selezionare quale parola
		 * della pool mettere in xor con w.
		 *
		 * Mettere sempre l'indice in and con wordmask evita gli overflow, in quanto vengono prelevati da esso solo i bit che
		 * non superano il size della pool.
		 *
		 * Di fatto, l'operazione seguente corrisponde ad un --i con overflow gestito tramite la wordmask
		 *
		 * Lo spostamento imposto dai tap rispetto a i indica quale x prelevare tra le parole della pool.
		 * La pool si comporta pertanto come una lista di valori di x
		 *
		 * Per capirne meglio l'uso, approfondire con http://eprint.iacr.org/2012/251.pdf
		 */
		i = (i - 1) & wordmask;

		/*
		 * le parole scelte dalla pool hano sempre la stessa distanza (i vari tap)
		 */
		/* XOR in the various taps */
		w ^= r->pool[i];
		w ^= r->pool[(i + tap1) & wordmask];
		w ^= r->pool[(i + tap2) & wordmask];
		w ^= r->pool[(i + tap3) & wordmask];
		w ^= r->pool[(i + tap4) & wordmask];
		w ^= r->pool[(i + tap5) & wordmask];

		/*
		 * l'i-esima parola dalle pool diviene w / 8 in xor con un elemento a caso della twist_table
		 */


		/* Mix the result back in with a twist */
		r->pool[i] = (w >> 3) ^ twist_table[w & 7];

		/*
		 * Normally, we add 7 bits of rotation to the pool.
		 * At the beginning of the pool, add an extra 7 bits
		 * rotation, so that successive passes spread the
		 * input bits across the pool evenly.
		 */
		input_rotate = (input_rotate + (i ? 7 : 14)) & 31;
	}
	/*
	 * vengono salvati gli ultimi input rotate e puntatore a parola nella pool
	 * add_ptr
	 */
	ACCESS_ONCE(r->input_rotate) = input_rotate;
	ACCESS_ONCE(r->add_ptr) = i;
	// solo una barriera
	smp_wmb();
	/*
	 * Se out è definito, ne vengono riempiti i primi 16 elementi con 16 valori consecutivi della pool letti al contrario
	 * (dalla posizione di scrittura nella pool corrente procedendo in senso inverso)
	 * Possibile lack di sicurezza? 
	 */
	if (out)
		for (j = 0; j < 16; j++)
			((__u32 *)out)[j] = r->pool[(i - j) & wordmask];
}

/*
 * esecuzione di _mix_pool_bytes preceduta da un trace, chiamata da extract_buf
 */
static void __mix_pool_bytes(struct entropy_store *r, const void *in,
			     int nbytes, __u8 out[64])
{
	trace_mix_pool_bytes_nolock(r->name, nbytes, _RET_IP_);
	_mix_pool_bytes(r, in, nbytes, out);
}

/*
 * reseed della pool r
 * in è il buffer di input, contiene i bytes randomici per il reseeding
 * nbytes è il numero di bytes utili nel buffer in
 * 
 * Acquisisce il lock per la pool e effettua il vero aggiornamento 
 * dello stato interno via _mix_pool_bytes
 */


static void mix_pool_bytes(struct entropy_store *r, const void *in,
			   int nbytes, __u8 out[64])
{
	unsigned long flags;
	//tralascia
	trace_mix_pool_bytes(r->name, nbytes, _RET_IP_);

	spin_lock_irqsave(&r->lock, flags);
	/*
	 * la vera funzione di mixing
	 */
	_mix_pool_bytes(r, in, nbytes, out);
	spin_unlock_irqrestore(&r->lock, flags);
}

/*
 * mini pool di 4 parole da 32 bit
 */
struct fast_pool {
	__u32		pool[4];
	unsigned long	last;
	unsigned short	count;
	unsigned char	rotate;
	unsigned char	last_timer_intr;
};

/*
 * This is a fast mixing routine used by the interrupt randomness
 * collector.  It's hardcoded for an 128 bit pool and assumes that any
 * locks that might be needed are taken by the caller.
 */

/*
 * compie un mix veloce tra una fast pool ed un buffer di 4 interi senza segno
 */
static void fast_mix(struct fast_pool *f, __u32 input[4])
{
	__u32		w;
	unsigned	input_rotate = f->rotate;

	w = rol32(input[0], input_rotate) ^ f->pool[0] ^ f->pool[3];
	f->pool[0] = (w >> 3) ^ twist_table[w & 7];
	input_rotate = (input_rotate + 14) & 31;
	w = rol32(input[1], input_rotate) ^ f->pool[1] ^ f->pool[0];
	f->pool[1] = (w >> 3) ^ twist_table[w & 7];
	input_rotate = (input_rotate + 7) & 31;
	w = rol32(input[2], input_rotate) ^ f->pool[2] ^ f->pool[1];
	f->pool[2] = (w >> 3) ^ twist_table[w & 7];
	input_rotate = (input_rotate + 7) & 31;
	w = rol32(input[3], input_rotate) ^ f->pool[3] ^ f->pool[2];
	f->pool[3] = (w >> 3) ^ twist_table[w & 7];
	input_rotate = (input_rotate + 7) & 31;

	f->rotate = input_rotate;
	f->count++;
}

/*
 * Credit (or debit) the entropy store with n bits of entropy.
 * Use credit_entropy_bits_safe() if the value comes from userspace
 * or otherwise should be checked for extreme values.
 */

/*
 * NOTA:
 * l'accredito di entropia ha un approccio lineare rispetto al debito,
 * asintotico rispetto all'accredito di bit di entropia
 *
 */

static void credit_entropy_bits(struct entropy_store *r, int nbits)
{
	int entropy_count, orig;
	/*
	 * poolfracbits è il numero di frazionali (ottavi) di bit di entropia stimati presso
	 * la pool;
	 *
	 * nbits equivale a quanto si vuole aumentare il valore dell'entropy counter
	 *
	 * - nfrac è pari al numero di bit che si vogliono accreditare per 2^3
	 * - ENTROPY_SHIFT sarebbe quindi il numero di decimali dei bit di etropia da considerare,
	 * - poolfracbits corrisponde al numero di bit della pool compresi i decimali e
	 * - nfrac è pari al numero totale di bit espresso in frazionali ( 2^(-3) ) che si vogliono accreditare
	 *   (ad esempio, se si vogliono accreditare in tutto 8 bit di entropia, nfrac è pari a 64)
	 *
	 * se non si vogliono accreditare bit, la funzione ritorna
	 */
	const int pool_size = r->poolinfo->poolfracbits;
	int nfrac = nbits << ENTROPY_SHIFT;

	if (!nbits)
		return;

	/*
	 * ciclo
	 */
retry:
	/*
	 * inizializza orig con il valore attuale dell'entropy counter della pool
	 */
	entropy_count = orig = ACCESS_ONCE(r->entropy_count);
	/*
	 * nel caso si stia imponendo un debito alla pool, vengono semplicemente sottratti
	 * all'entropy counter nfrac bits
	 */
	if (nfrac < 0) {
		/* Debit */
		entropy_count += nfrac;
	} else {
		/*
		 * Credit: we have to account for the possibility of
		 * overwriting already present entropy.	 Even in the
		 * ideal case of pure Shannon entropy, new contributions
		 * approach the full value asymptotically:
		 *
		 * entropy <- entropy + (pool_size - entropy) *
		 *	(1 - exp(-add_entropy/pool_size))
		 *
		 * For add_entropy <= pool_size/2 then
		 * (1 - exp(-add_entropy/pool_size)) >=
		 *    (add_entropy/pool_size)*0.7869...
		 * so we can approximate the exponential with
		 * 3/4*add_entropy/pool_size and still be on the
		 * safe side by adding at most pool_size/2 at a time.
		 *
		 * The use of pool_size-2 in the while statement is to
		 * prevent rounding artifacts from making the loop
		 * arbitrarily long; this limits the loop to log2(pool_size)*2
		 * turns no matter how large nbits is.
		 */

		/*
		 * leggi il commento sopra
		 */
		int pnfrac = nfrac;
		/*
		 * Da qui in poi viene implementato quanto scritto nel commento sopra
		 * Il ciclo per il calcolo dell'asintoto termina quando entropy_count è minore
		 * di pool size (unlikely ottimizza informando il compilatore che la condizione è
		 * più tipicamente non soddisfatta)
		 * oppure (soprattutto) quando non ci sono più bit da accreditare (pnfrac =0)
		 *
		 * il +2 in s corrisponde ad un /4 nell'equazione in cui viene utilizzato
		 *
		 */
		const int s = r->poolinfo->poolbitshift + ENTROPY_SHIFT + 2;
		/* The +2 corresponds to the /4 in the denominator */

		do {
			/*
			 * si accreditano al più la metà dei bit rispetto alla dimensione della pool in bit
			 */
			unsigned int anfrac = min(pnfrac, pool_size/2);
			/*
			 * La stima dell'entropia è pari a:
			 * (pool_size-entropy_count)* <numero di bit di entropia da aggiungere a questo giro del while espresso in ottavi di bit>
			 * / (<dimensione in bit ottavi di bit della pool per 4)
			 *
			 * il 3 al numeratore e 2 in s (equivalente a un divisore 4) danno per
			 * risultato 0.75, ovvero una stima ancora più
			 * pessimistica rispetto a quanto affermato dalla disequazione del commento
			 * (pool_size - entropy_count)*anfrac* / pool_size * 0.7869
			 */
			unsigned int add =
				((pool_size - entropy_count)*anfrac*3) >> s;
			entropy_count += add;
			pnfrac -= anfrac;
		} while (unlikely(entropy_count < pool_size-2 && pnfrac));
	}

	/*
	 * L'entropy count della pool è negativo
	 * il valore viene corretto a zero
	 */
	if (entropy_count < 0) {
		pr_warn("random: negative entropy/overflow: pool %s count %d\n",
			r->name, entropy_count);
		WARN_ON(1);
		entropy_count = 0;
	}
	/*
	 * se il contatore di entropia è maggiore della dimensione della pool, correggi
	 * (ma non dovrebbe essere possibile, avvicinandosi il contatore in modo asintotico alla
	 * dimensione della pool. Di fatto sembra solo un codice per aumentare la robustezza)
	 */
	else if (entropy_count > pool_size)
		entropy_count = pool_size;

	/*
	 * funzone di compare e exchange:
	 * se il valore in memoria di entropy_count è uguale a orig, lo sostituisce col nuovo entropy count e ritorna il valore
	 * di orig se la comparazione ha avuto successo, non fa nulla e ritorna altro altrimenti.
	 *
	 * Se orig non corrisponde al valore in memoria, vuol dire che sono avvenuti accessi concorrenti e la procedura deve essere
	 * rieseguita.
	 */
	if (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
		goto retry;

	/*
	 * entropy_total contiene il numero intero di bits di entropia
	 * della pool (aggiunti o sottratti finora).
	 */
	r->entropy_total += nbits;
	/*
	 * Se la pool non è stata inizializzata e il conto totale di bit di entropia (intero)
	 * è maggiore di 128 (non esiste un controllo sulla dimensione che può assumere entropy_total)
	 * inizializza la pool:
	 * 		1. il totale dei bit di entropia è azzerato
	 * 		2. se la pool è quella non bloccante, invoca un reseed
	 * 		(tardivo perché se viene eseguita questa sezione di codice potrebbero essere
	 * 		già stato fatto un prelievo da nonblocking) fatto tramite l'uso di valori prelevati
	 * 		con get_random_bytes (quindi sempre provenienti dalla pool nonblocking!).
	 */
	if (!r->initialized && r->entropy_total > 128) {
		r->initialized = 1;
		r->entropy_total = 0;
		if (r == &nonblocking_pool) {
			prandom_reseed_late();
			pr_notice("random: %s pool is initialized\n", r->name);
		}
	}

	//tralascia
	trace_credit_entropy_bits(r->name, nbits,
				  entropy_count >> ENTROPY_SHIFT,
				  r->entropy_total, _RET_IP_);


	/*
	 * caso input pool!
	 */
	if (r == &input_pool) {

		/*
		 * Conversione da ottavi di bit a bytes
		 */
		int entropy_bytes = entropy_count >> ENTROPY_SHIFT;

		/* should we wake readers? */
		if (entropy_bytes >= random_read_wakeup_thresh) {
			/*
			 * Se i bytes di entropy_bytes sono oltre la soglia per la
			 * lettura, vengono svegliati i processi in attesa di leggere
			 */
			wake_up_interruptible(&random_read_wait);
			/*
			 * ancora fasync...
			 * approfondire
			 * ***
			 */
			kill_fasync(&fasync, SIGIO, POLL_IN);
		}
		/* If the input pool is getting full, send some
		 * entropy to the two output pools, flipping back and
		 * forth between them, until the output pools are 75%
		 * full.
		 */

		/*
		 * La soglia random_write_wakeup_thresh indica quanto detto nel commento originale:
		 * sel la input pool sta riempiendosi, inizia uno scambio
		 * tra la input pool e le due pool di output, fino a che queste raggiungano un'entropia del 75%.
		 *
		 * La condizione verifica che la input pool abbia sufficiente entropia anche rispetto alla condizione di read (il doppio)
		 */
		if (entropy_bytes > random_write_wakeup_thresh &&
		    r->initialized &&
		    r->entropy_total >= 2*random_read_wakeup_thresh) {
			static struct entropy_store *last = &blocking_pool;
			struct entropy_store *other = &blocking_pool;

			/*
			 * Se l'entropia della nonblocking pool è maggiore al 75% della sua capacità,
			 * schedula un refeeding per la blocking pool, altrimenti per la
			 * pool nonblocking (ma non per due volte consecutive).
			 */

			if (last == &blocking_pool)
				other = &nonblocking_pool;

			if (other->entropy_count <=
			    3 * other->poolinfo->poolfracbits / 4)
				last = other;

			/*
			 * Se last ha un'entropia superiore al 75% della sua capacità, viene schedulato il work push_to_pool
			 * per last.
			 *
			 * poolfracbits è un valore statico, l'utilizzo dell'operatore aritmetico / consente al compilatore
			 * di ottimizzare.
			 *
			 */
			if (last->entropy_count <=
			    3 * last->poolinfo->poolfracbits / 4) {
				schedule_work(&last->push_work);
				r->entropy_total = 0;
			}
		}//fine caso input pool con sufficiente entropia
	}//fine caso input pool
}

/*
 * Funzione chiamata quando l'entropia è aggiunta dallo spazio utente.
 * Controlla che il numero di bit da aggiungere non provochi overflow.
 *
 * nbits_max è una maschera di (31-entropy_shift) bits 1
 * Di fatto consiste in un upper bound per il numero di bit di entropia che
 * possono essere aggiunti in un'unica operazione di input di entropia.
 *
 * L'overflow è evitato se nbits è minore di nbits_max e
 * maggiore di -nbits_max (un eventuale debito non comporta un overflow negativo)
 *
 * La riduzione della maschera di entropy-shift tiene conto del fatto che
 * entropy count è un intero che contempla bit in quantità frazionaria: l'overflow può
 * quindi scarturire per accrediti il cui ordine di grandezza è di (31-entropy_shift)
 */
static void credit_entropy_bits_safe(struct entropy_store *r, int nbits)
{
	const int nbits_max = (int)(~0U >> (ENTROPY_SHIFT + 1));

	/* Cap the value to avoid overflows */
	nbits = min(nbits,  nbits_max);
	nbits = max(nbits, -nbits_max);

	credit_entropy_bits(r, nbits);
}

/*********************************************************************
 *
 * Entropy input management
 *
 *********************************************************************/

/* There is one of these per entropy source */
/*
 * Ogni sorgente è modellata da una struttura del tipo
 */
struct timer_rand_state {
	cycles_t last_time;
	long last_delta, last_delta2;
	unsigned dont_count_entropy:1;
};

/* Inizializza una timer_rand_state con last_time pari al numero di jiffies
 * iniziale fissato per convenzione
 */
#define INIT_TIMER_RAND_STATE { INITIAL_JIFFIES, };

/*
 * Add device- or boot-specific data to the input and nonblocking
 * pools to help initialize them to unique values.
 *
 * None of this adds any entropy, it is meant to avoid the
 * problem of the nonblocking pool having similar initial state
 * across largely identical devices.
 */
/*
 * Come descritto sopra, inizializza le pool input e nonblocking con valori dipendenti dal tipo
 * di macchina. Non viene aggiunta vera entropia, ma differenzia gli stati iniziali tra macchine
 * diverse.
 */
void add_device_randomness(const void *buf, unsigned int size)
{
	/*
	 * time contiene il get_cycles (che è diverso da zero solo se implementato per
	 * l'architettura specifica, nel caso di x86 è implementata) in and con il numero di jiffies
	 */
	unsigned long time = random_get_entropy() ^ jiffies;
	unsigned long flags;
	//tralascia
	trace_add_device_randomness(size, _RET_IP_);

	// mischia ai dati della pool il buffer e il time


	spin_lock_irqsave(&input_pool.lock, flags);
	_mix_pool_bytes(&input_pool, buf, size, NULL);
	_mix_pool_bytes(&input_pool, &time, sizeof(time), NULL);
	spin_unlock_irqrestore(&input_pool.lock, flags);

	spin_lock_irqsave(&nonblocking_pool.lock, flags);
	_mix_pool_bytes(&nonblocking_pool, buf, size, NULL);
	_mix_pool_bytes(&nonblocking_pool, &time, sizeof(time), NULL);
	spin_unlock_irqrestore(&nonblocking_pool.lock, flags);
}
EXPORT_SYMBOL(add_device_randomness);

/* Inizializza una input_timer_state con last_time pari al numero di jiffies
 * iniziale fissato per convenzione */
static struct timer_rand_state input_timer_state = INIT_TIMER_RAND_STATE;

/*
 * This function adds entropy to the entropy "pool" by using timing
 * delays.  It uses the timer_rand_state structure to make an estimate
 * of how many bits of entropy this call has added to the pool.
 *
 * The number "num" is also added to the pool - it should somehow describe
 * the type of event which just happened.  This is currently 0-255 for
 * keyboard scan codes, and 256 upwards for interrupts.
 *
 */
/*
 * La stima dei bits di entropia da aggiungere è effettuata attraverso la struct
 * timer_rand_state. Lo state contiene il numero di jiffies dell'ultima occorrenza (last_time),
 * i due ultimi delta e un valore numerico unsigned
 *
 * num codifica il tipo di evento occorso (0-255 per la tastiera, da 256 in
 * poi per gli altri interrupts)
 */
static void add_timer_randomness(struct timer_rand_state *state, unsigned num)
{

	struct entropy_store	*r;
	struct {
		long jiffies;
		unsigned cycles;
		unsigned num;
	} sample;
	long delta, delta2, delta3;

	/*
	 * Inizio sezione critica.
	 */
	preempt_disable();

	/*
	 * inizializza sample con il campione raccolto
	 */
	sample.jiffies = jiffies;
	sample.cycles = random_get_entropy();
	sample.num = num;
	/*
	 * se la pool nonblocking è già stata inizializzata, allora r è la input pool, la nonblocking altrimenti.
	 * Il campione è mischiato con la input pool (nonblocking)
	 *
	 * sample è grande 8+4+4 bytes = 128 bit che costituiscono il buffer che viene mischiato
	 * alla pool a questo punto dell'add_timer_randomness
	 * Questa aggiunta è effettuata indipendentemente dal tipo di interrupt che l'ha generata
	 * ed è costituita SOLO da cicli, jiffies e valore numerico
	 */
	r = nonblocking_pool.initialized ? &input_pool : &nonblocking_pool;
	mix_pool_bytes(r, &sample, sizeof(sample), NULL);

	/*
	 * Calculate number of bits of randomness we probably added.
	 * We take into account the first, second and third-order deltas
	 * in order to make our estimate.
	 */

	/*
	 * Fa una stima dei bit di entropia aggiunti.
	 * Osserva l'evoluzione dei tre delta.
	 */
	if (!state->dont_count_entropy) {
		delta = sample.jiffies - state->last_time;
		// last_time è pari al jiffies del nuovo campione raccolto
		state->last_time = sample.jiffies;

		/*
		 * delta è pari alla differenza dei jiffies tra i due ultimi eventi dello stesso tipo
		 * delta 2 è la differenza tra il nuovo delta calcolato e il vecchio (può essere positivo o negativo)
		 * delta3 è la differenza tra il nuovo e vecchio delta2
		 *
		 * Una volta copiati delta e delta2 in state, i valori negativi dei tre delta vengono invertiti,
		 * il valore assoluto minimo viene salvato in delta.
		 *
		 */
		delta2 = delta - state->last_delta;
		state->last_delta = delta;

		delta3 = delta2 - state->last_delta2;
		state->last_delta2 = delta2;

		if (delta < 0)
			delta = -delta;
		if (delta2 < 0)
			delta2 = -delta2;
		if (delta3 < 0)
			delta3 = -delta3;
		if (delta > delta2)
			delta = delta2;
		if (delta > delta3)
			delta = delta3;

		/*
		 * delta is now minimum absolute delta.
		 * Round down by 1 bit on general principles,
		 * and limit entropy entimate to 12 bits.
		 */
		/*
		 * La stima dei bit di entropia aggiunti corrisponde al valore assoluto minimo tra i tre delta (salvato nella variabile delta),
		 * diviso 2
		 *
		 * min_t(int,a,b) restituisce il minore tra gli interi a e b.
		 * fls(delta>>1) ritorna un valore logaritmico di delta.
		 * nella fattispecie, la pool r viene accreditata di un numero di bits pari al minimo tra
		 * la metà del numero di zeri a destra di delta e 11. Misura molto pessimistica!
		 */

		credit_entropy_bits(r, min_t(int, fls(delta>>1), 11));
	}
	/*
	 * rilascia la preemption
	 */
	preempt_enable();
}

/*
 * Aggiunge entropia a partire dagli input provenienti dall'utente (mouse e tastiera)
 *
 * Aggiunge entropia per il tipo input_timer_state, utilizzando come valore un mix
 * dei tre valori:
 * 		type - codifica la sorgente dell'evento di input (tastiera, mouse, touchscreen, ecc.)
 * 		code - il codice dell'input (ad esempio quale tasto della tastiera o del mouse è stato premuto o rilasciato)
 *		value - il valore dell'input, specifica quale evento specifico è occorso per il codice code (ad
 *				esempio se il tasto è stato premuto, mantenuto o rilasciato, ecc)
 */
void add_input_randomness(unsigned int type, unsigned int code,
				 unsigned int value)
{
	/* Ad ogni invocazione viene aggiornato il valore di last_value
	 * Se il valore è uguale all'ultimo processato,
	 * la funzione è idempotente.
	 * Questo impedisce che sorgenti di entropia fiume sottopongano sempre lo stesso valore.*/
	static unsigned char last_value;

	/* ignore autorepeat and the like */

	if (value == last_value)
		return;

	last_value = value;
	/* Viene aggiunta */
	add_timer_randomness(&input_timer_state,
			     (type << 4) ^ code ^ (code >> 4) ^ value);
	//tralascia
	trace_add_input_randomness(ENTROPY_BITS(&input_pool));
}
EXPORT_SYMBOL_GPL(add_input_randomness);

static DEFINE_PER_CPU(struct fast_pool, irq_randomness);

/*
 * Aggiunge entropia a partire da un'irq
 */
void add_interrupt_randomness(int irq, int irq_flags)
{
	struct entropy_store	*r;
	/*
	 * da notare l'uso di una fast_pool
	 * La fast pool è inizializzata con le variabili percpu, ovvero con una descrizione della macchina
	 * presente.
	 */
	struct fast_pool	*fast_pool = &__get_cpu_var(irq_randomness);
	/*
	 * registri irq
	 */
	struct pt_regs		*regs = get_irq_regs();
	unsigned long		now = jiffies;
	cycles_t		cycles = random_get_entropy();
	__u32			input[4], c_high, j_high;
	__u64			ip;

	/*
	 * c_high e j_high contengono i primi 32 bit (i primi 4 bytes) rispettivamente di cycles e now
	 * nel caso in cui il loro size sia maggiore strettamente di 4 bytes, oppure 0 se altrimenti.
	 *
	 * c_high è pertanto diverso da 0 nel caso in cui l'architettura sia x86 (cycles è un unsigned long long)
	 * o una qualunque a 64 bit (cycles è un unsigned long).
	 *
	 * similmente j_high è diverso da zero solo nelle architetture a 64 bit (unsigned long)
	 */
	c_high = (sizeof(cycles) > 4) ? cycles >> 32 : 0;
	j_high = (sizeof(now) > 4) ? now >> 32 : 0;

	/*
	 * input[0] è composto dal numero totale di cicli in xor con la parte alta dei jiffies e
	 * con l'identificativo della irq
	 *
	 * input [1] è pari al numero attuale di jiffies in xor con la parte alta dei cicli.
	 *
	 * ip è l'istruction_pointer per l'istruzione per la gestione dell'interruzione.
	 *
	 * le ultime due parole di input sono l'istruction pointer stesso, nelle sue parti bassa e alta.
	 */
	input[0] = cycles ^ j_high ^ irq;
	input[1] = now ^ c_high;
	ip = regs ? instruction_pointer(regs) : _RET_IP_;
	input[2] = ip;
	input[3] = ip >> 32;

	/*
	 * Le quattro parole in input sono mischiate nella fast pool.
	 */
	fast_mix(fast_pool, input);

	/*
	 * se gli ultimi 6 bit del counter non sono 0 (count è uno short incrementato di uno ad ogni fast
	 * mix della pool) e se now non supera di almeno 100 jiffies il momento dell'ultimo
	 * aggiornamento di fast_pool (ovvero l'ultimo interrupt visto dalla CPU è troppo recente rispetto a now),
	 * la funzione ritorna senza aggiornare le pool principali.
	 *
	 * Nel caso ritorni, l'unico effetto della routine è di aver aggiornato la fast_pool irq_randomness.
	 */
	if ((fast_pool->count & 63) && !time_after(now, fast_pool->last + HZ))
		return;

	// aggiorna last
	fast_pool->last = now;

	/*
	 * se la pool nonblocking è inizializzata r è la input pool,
	 * altrimenti è la nonblocking pool
	 *
	 * Vengono mischiati i bytes dell'intera fast_pool con quelli della pool in esame.
	 */
	r = nonblocking_pool.initialized ? &input_pool : &nonblocking_pool;
	__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool), NULL);
	/*
	 * If we don't have a valid cycle counter, and we see
	 * back-to-back timer interrupts, then skip giving credit for
	 * any entropy.
	 */
	/*
	 * se non c'è un contatore di cicli valido o gli interrupt dei timer giungono uno dopo
	 * l'altro, non viene accreditata alcuna entropia.
	 */
	if (cycles == 0) {
		if (irq_flags & __IRQF_TIMER) {
			if (fast_pool->last_timer_intr)
				return;
			fast_pool->last_timer_intr = 1;
		} else
			fast_pool->last_timer_intr = 0;
	}
	/*
	 * accredita un solo bit di entropia a r.
	 */
	credit_entropy_bits(r, 1);
}

#ifdef CONFIG_BLOCK
void add_disk_randomness(struct gendisk *disk)
{
	if (!disk || !disk->random)
		return;
	/* first major is 1, so we get >= 0x200 here */
	add_timer_randomness(disk->random, 0x100 + disk_devt(disk));
	trace_add_disk_randomness(disk_devt(disk), ENTROPY_BITS(&input_pool));
}
#endif

/*********************************************************************
 *
 * Entropy extraction routines
 *
 *********************************************************************/

static ssize_t extract_entropy(struct entropy_store *r, void *buf,
			       size_t nbytes, int min, int rsvd);

/*
 * This utility inline function is responsible for transferring entropy
 * from the primary pool to the secondary extraction pool. We make
 * sure we pull enough for a 'catastrophic reseed'.
 */
/*
 * Ogni chiamata a xfer_secondary_pool compiuta dalle funzioni di estrazione deve essere
 * seguita dall'esecuzione di account.
 */
static void _xfer_secondary_pool(struct entropy_store *r, size_t nbytes);
static void xfer_secondary_pool(struct entropy_store *r, size_t nbytes)
{
	/*
	 * r->limit è zero nel caso r sia urandom
	 * random_min_urandom_seed è il numero minimo di secondi che deve intercorrere tra due reseed consecutivi della
	 * nonblocking pool dall'input pool. Serve a impedire il prosciugamento dell'entropia dalla pool primaria
	 * anche se a urandom vengono sottoposte molte richieste.
	 * È impostato a 60, quindi di fatto l'if è attivato ogni volta che la pool è urandom.
	 *
	 * Se now viene prima del momento di prelievo possibile (r->last_pulled+ il
	 * numero minimo di secondi che devono intercorrere prima del reseed), allora la funzione ritorna,
	 * altrimenti è possibile fare il reseed e r->last_pulled è impostato ai jiffies correnti.
	 *
	 * In altre parole, questo if serve a discriminare il caso la pool secondaria sia urandom:
	 * poiché xfer_secondary serve fondamentalmente per il reseed della pool, se urandom ha già avuto un reseed da meno di 60 secondi
	 * xfer_secondary_... non ha nessun effetto, altrimenti procede per il reseed.
	 *
	 * Nel caso di blocking_pool invece la funzione viene eseguita e basta.
	 */
	if (r->limit == 0 && random_min_urandom_seed) {
		unsigned long now = jiffies;

		if (time_before(now,
				r->last_pulled + random_min_urandom_seed * HZ))
			return;
		r->last_pulled = now;
	}
	/*
	 * r->pull punta alla input_pool o a null nel caso in cui r sia già l'input pool
	 *
	 * L'if è verificato se (contemporaneamente):
	 * 		1. la pool non è la input pool (ovviamente!)
	 * 		2. l'entropy count è minore del numero di ottavi di bit da prelevare (#bytes * 2^3 (bit) * 2^3 (ottavi di bit))
	 * 		3. l'entropy count è minore di poolfracbits, ovvero il numero di parole della pool moltiplicato per 2^8
	 * 		(il numero di parole per una pool secondaria è di 32 word).
	 *
	 * 	L'attivazione dell'if comporta il reseeding della pool effettivo (_xfer_secondary_pool)
	 */

	if (r->pull &&
	    r->entropy_count < (nbytes << (ENTROPY_SHIFT + 3)) &&
	    r->entropy_count < r->poolinfo->poolfracbits)
		_xfer_secondary_pool(r, nbytes);
}

/*
 * Si occupa del trasferimento di entropia dalla input pool alla
 * pool di output passata per parametro
 */

static void _xfer_secondary_pool(struct entropy_store *r, size_t nbytes)
{
	/*
	 * buffer di dimensione pari al numero di parole in output per una pool secondaria
	 */
	__u32	tmp[OUTPUT_POOL_WORDS];

	/* For /dev/random's pool, always leave two wakeup worth's BITS */
	/*
	 * Se la pool è blocking, rsvd è 0.
	 * Se la pool è urandom, rsvd è impostata al valore del numero soglia di bit di entropia nella pool primaria
	 * prima di poter effettuare un prelievo, diviso 4.
	 *
	 */
	int rsvd = r->limit ? 0 : random_read_wakeup_thresh/4;

	/*
	 * bytes è inizializzato col valore del buffer che si vuole estrarre,
	 * e viene limitato in alto dalla dimensione del buffer tmp = 128
	 * e in basso da random_read_wakeup_thresh/8=8
	 *  8<= bytes <=128
	 *
	 */
	int bytes = nbytes;

	/* pull at least as many as BYTES as wakeup BITS */
	bytes = max_t(int, bytes, random_read_wakeup_thresh / 8);
	/* but never more than the buffer size */
	bytes = min_t(int, bytes, sizeof(tmp));

	//tralascia
	trace_xfer_secondary_pool(r->name, bytes * 8, nbytes * 8,
				  ENTROPY_BITS(r), ENTROPY_BITS(r->pull));

	/*
	 * extract entropy dalla pool primaria, sul buffer tmp per bytes bytes,
	 * da cui si devono ottenere almeno 8 bytes.
	 * Nel caso si stesse compiendo il reseeding di urandom, nella pool primaria devono essere lasciati almeno
	 * 8 bytes di entropia, nel caso il reseeding in atto fosse per blocking non occorre lasciare nulla.
	 *
	 */
	bytes = extract_entropy(r->pull, tmp, bytes,
				random_read_wakeup_thresh / 8, rsvd);

	/*
	 * mischia i bytes estratti con quelli della pool secondaria
	 * Da sola non aggiorna l'entropy counter
	 */
	mix_pool_bytes(r, tmp, bytes, NULL);
	/*
	 * aggiorna l'entropy counter
	 */
	credit_entropy_bits(r, bytes*8);
}


/*
 * Used as a workqueue function so that when the input pool is getting
 * full, we can "spill over" some entropy to the output pools.  That
 * way the output pools can store some of the excess entropy instead
 * of letting it go to waste.
 */

/*
 * push_to_pool è puntata dal campo push_work delle output pool,
 * viene schedulata da credit_entropy_bits quando nella input pool
 * c'è più del 7/8 della capienza di entropia
 *
 * Chiama la routine per il trasferimento di 8 bytes entropia dalla input pool
 * alla pool contenente work.
 */
 
static void push_to_pool(struct work_struct *work)
{
	/*
	 * container_of ritorna la struttura che contiene il campo
	 * (in questo caso da un work si riottiene la struttura di tipo
	 * entropy_store che lo contiene)
	 *
	 * Da include/linux/kernel.h:
	 * container_of - cast a member of a structure out to the containing structure
	 * @ptr:	the pointer to the member.
	 * @type:	the type of the container struct this is embedded in.
	 * @member:	the name of the member within the struct.
	 *
	 */
	struct entropy_store *r = container_of(work, struct entropy_store,
					      push_work);
	//...
	BUG_ON(!r);
	/*
	 * trasferisce verso la pool r un'entropia pari a un ottavo della soglia
	 * random_read_wakeup_thresh,
	 * di entropia che deve essere raggiunta dalla pool bloccante
	 * prima di risvegliare una lettura bloccata su /dev/random
	 *
	 * Non sono compiuti shift perché il compilatore ottimizza l'operazione
	 * di divisione in maniera statica (random_read_wakeup_thresh è una macro)
	 */
	_xfer_secondary_pool(r, random_read_wakeup_thresh/8);
	//tralasciato
	trace_push_to_pool(r->name, r->entropy_count >> ENTROPY_SHIFT,
			   r->pull->entropy_count >> ENTROPY_SHIFT);
}


/*
 * These functions extracts randomness from the "entropy pool", and
 * returns it in a buffer.
 *
 * The min parameter specifies the minimum amount we can pull before
 * failing to avoid races that defeat catastrophic reseeding while the
 * reserved parameter indicates how much entropy we must leave in the
 * pool after each pull to avoid starving other readers.
 *
 * Note: extract_entropy() assumes that .poolwords is a multiple of 16 words.
 */

/*
 * La routine ritorna il numero di bytes che possono essere estratti dalla pool
 * e sveglia i thread addetti alla scrittura.
 * Nel caso la pool sia bloccante pertanto la funzione ritorna con il numero di bytes di
 * entropia estraibile dalla pool, mentre nel caso la pool sia nonblocking il valore di ritorno
 * è pari al numero di bytes richiesti.
 * In entrambi i casi comunque l'entropy counter della pool viene aggiornato con il valore corretto.
 * La diversa gestione dei due casi in account(), assieme alle funzioni random_read() e urandom_read()
 *  è alla base della differenza funzionale delle interfacce dello spazio utente random e urandom.
 *  NOTA: il commento originale è datato e non più coerente.
 */

static size_t account(struct entropy_store *r, size_t nbytes, int min,
		      int reserved)
{
	unsigned long flags;
	int wakeup_write = 0;
	int have_bytes;
	int entropy_count, orig;
	size_t ibytes;

	/* Hold lock while accounting */
	spin_lock_irqsave(&r->lock, fla, cuigs);

	BUG_ON(r->entropy_count > r->poolinfo->poolfracbits);

	/* Can we pull enough? */
retry:
	/*
	 * Access once è una funzione di lettura semplice, serve a proteggere gli accessi in cpu di lettura dalle interruzioni
	 *
	 * orig e entropy count inizializzati entrambi con il valore dell'entropy count della pool r
	 * havebytes è inizializzato con il numero di bytes di entropia
	 * (calcolati a partire dagli ottavi di bit di entropy_count)
	 * ibytes inizializzato a nbytes
	 *
	 */
	entropy_count = orig = ACCESS_ONCE(r->entropy_count);
	have_bytes = entropy_count >> (ENTROPY_SHIFT + 3);
	ibytes = nbytes;

	/*
	 * controlla la somma di min e reserved contro have_bytes
	 * se la somma è sotto la soglia ibytes è messa a zero e la
	 * funzione ritorna 0 come numero di bytes estratti.
	 *
	 */
	if (have_bytes < min + reserved) {
		ibytes = 0;
	} else {

		/*
		 * La soglia è rispettata, c'è dell'entropia da estrarre.
		 *
		 * L'entropia estraibile, nel caso in cui la
		 * pool r sia blocking (r->limit) e nbytes sia troppo grande, è
		 * memorizzata in ibytes ed è pari a have_bytes - reserved.
		 *
		 * Nel caso in cui la pool sia bloccante, viene calcolato
		 * ibytes come la differenza tra i bytes della pool e
		 * i bytes reserved che devono essere lasciati "a terra".
		 *
		 */
		/* If limited, never pull more than available */

		if (r->limit && ibytes + reserved >= have_bytes)
			ibytes = have_bytes - reserved;

		/*
		 * Questa condizione è verificata banalmente se la pool era bloccante (per l'effetto dell'if precedente),
		 * oppure nel caso in cui la pool sia urandom e il numero nbytes (con cui era inizializzato ibytes) + il numero
		 * di bytes da riservare non ecceda have_bytes.
		 *
		 * Se la condizione è verificata, sottrae al'entropy_count della pool il numero di ottavi di bit che si vogliono estrarre
		 * (notare che nel caso di limit = 0 ibytes coincide con nbytes)
		 *
		 * La condizione non è verificata se il numero di bytes richiesti più quelli riservati eccede quelli di have_bytes.
		 * In questo caso il conteggio dell'entropia è aggiornato ad una costante (sembra pertanto un minimo),
		 * calcolato come il numero di ottavi di bit dei bytes che andrebbero riservati.
		 *
		 */

		if (have_bytes >= ibytes + reserved)
			entropy_count -= ibytes << (ENTROPY_SHIFT + 3);
		else
			entropy_count = reserved << (ENTROPY_SHIFT + 3);

		/*
		 * Compare exchange cmpxchg(ptr, old, new):
		 * se i valori di ptr e old coincidono, allora la funzione ritorna il puntatore old e il nuovo valore
		 * in memoria viene impostato con quello di new.
		 *
		 * Questo significa che se è cambiato il valore di r->entropy_count della pool rispetto a quello
		 * memorizzato in orig, viene attivato il goto, altrimenti viene aggiornato il campo di r->entropy_count
		 * con il nuovo entropy_count calcolato.
		 *
		 * Serve a gestire la concorrenza: se un qualche thread ha modificato il valore di r->entropy_count prima
		 * di quello corrente occorre fare un nuovo tentativo.
		 */
		if (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
			goto retry;


		/*
		 * Se il numero di bit interi di r->entropy_count  è minore di random_write_wakeup_thresh
		 * imposta a true wakeup_write.
		 * wakeup_write viene quindi attivata se e solo se r->entropy_count cade sotto la soglia,
		 * serve a abilitare il wake up dei thread bloccati in scrittura nell'atto di aggiungere entropia.
		 *
		 * La soglia è impostata a 28 word.
		 *
		 * Se le pool di output hanno meno di 28 parole di entropia(su un massimo di 32), eventuali thread in attesa
		 * di aggiungere entropia alla pool di input vengono svegliati (if più in basso).
		 */
		if ((r->entropy_count >> ENTROPY_SHIFT)
		    < random_write_wakeup_thresh)
			wakeup_write = 1;
	}
	spin_unlock_irqrestore(&r->lock, flags);

	trace_debit_entropy(r->name, 8 * ibytes);

	if (wakeup_write) {
		/*
		 * sveglia i thread in attesa su random_write
		 */
		wake_up_interruptible(&random_write_wait);
		//...
		kill_fasync(&fasync, SIGIO, POLL_OUT);
	}

	return ibytes;
}

/*
 * Estrae un hash dalla pool
 */
static void extract_buf(struct entropy_store *r, __u8 *out)
{
	int i;
	/*
	 * hash.w contiene 5 parole a 32 bit che contengono l'hash proveniente dall'applicazione di sha1 alla pool
	 * l contiene tanti long quanti ne servono per totalizzare 20 bytes
	 */
	union {
		__u32 w[5];
		unsigned long l[LONGS(20)];
	} hash;
	__u32 workspace[SHA_WORKSPACE_WORDS];
	__u8 extract[64];
	unsigned long flags;

	/* Generate a hash across the pool, 16 words (512 bits) at a time */
	/*
	* inizializza hash.w con 5 uint sufficientemente "strani" (sempre gli stessi)
	*/
	sha_init(hash.w);
	spin_lock_irqsave(&r->lock, flags);

	/*
	 * applica uno sha1 16 volte alle 5 parole di hash.w
	 * sha_transform richiede che, in caso siano richiesti hash security sensitive,
	 * il buffer workspace sia impostato a zero, presumibilmente perché non è ancora stato
	 * studiata a fondo la sicurezza del suo uso all'interno della funzione. Un workspace 0
	 * infatti non da nessun apporto.
	 *
	 */
	for (i = 0; i < r->poolinfo->poolwords; i += 16)
		sha_transform(hash.w, (__u8 *)(r->pool + i), workspace);

	/*
	 * If we have a architectural hardware random number
	 * generator, mix that in, too.
	 */
	/*
	 * Se esiste un generatore di randomicità hardware, hash.l contiene, alla fine del ciclo,
	 * 5 o 4 unsigned long (rispettivamente nel caso di architetture a 32 e 64 bit)
	 * provenienti dal generatore di entropia hw.
	 * hash.l alla fine contiene tutti valori inizializzati attraverso la sorgente hardware.
	 */
	for (i = 0; i < LONGS(20); i++) {
		unsigned long v;
		if (!arch_get_random_long(&v))
			break;
		hash.l[i] ^= v;
	}

	/*
	 * We mix the hash back into the pool to prevent backtracking
	 * attacks (where the attacker knows the state of the pool
	 * plus the current outputs, and attempts to find previous
	 * ouputs), unless the hash function can be inverted. By
	 * mixing at least a SHA1 worth of hash data back, we make
	 * brute-forcing the feedback as hard as brute-forcing the
	 * hash.
	 */
	/*
	 * Robustezza al backward recovery.
	 * L'hash hash.w è mischiato alla pool di origine.
	 * Contestualmente viene estratto un buffer, extract,
	 *  di 64 parole da 8 bit a partire dalle ultime 16
	 * parole della pool lette in senso inverso.
	 *
	 */
	__mix_pool_bytes(r, hash.w, sizeof(hash.w), extract);
	spin_unlock_irqrestore(&r->lock, flags);

	/*
	 * To avoid duplicates, we atomically extract a portion of the
	 * pool while mixing, and hash one final time.
	 */
	/*
	 * applica nuovamente uno sha 1 su hash.w con il buffer extract
	 * estratto durante il primo mixing dell'hash nella pool.
	 * Vengono azzerati sia extract (per ragioni di sicurezza,
	 * contiene la coda della pool rispetto al contatore corrente)
	 * che workspace (credo sia più per paranoia)
	 */
	sha_transform(hash.w, extract, workspace);
	memset(extract, 0, sizeof(extract));
	memset(workspace, 0, sizeof(workspace));

	/*
	 * In case the hash function has some recognizable output
	 * pattern, we fold it in half. Thus, we always feed back
	 * twice as much data as we output.
	 */
	/*
	 * fast mixing di hash.w per confondere i dati tramite xor e rotazioni
	 * Facilmente reversibile
	 */
	hash.w[0] ^= hash.w[3];
	hash.w[1] ^= hash.w[4];
	hash.w[2] ^= rol32(hash.w[2], 16);

	/*
	 * memorizza nel buffer di output l'hash ottenuto
	 */
	memcpy(out, &hash, EXTRACT_SIZE);
	/*
	 * pulisci hash
	 */
	memset(&hash, 0, sizeof(hash));
}


/*
 * cerca di estrarre dalla pool r un numero di bytes pari a nbytes.
 * min è la quantità minima accettabile di entropia da prelevare: se non
 * sono disponibili almeno min bytes, non ne viene prelevato nemmeno uno.
 * Reserved è la quantità di entropia che deve essere mantenuta nella pool
 *
 * Il prelievo dei bytes dalla pool compie i passi:
 * 	1. Trasferisce dalla input pool (possibilmente) nbytes e li mischia alla
 *     pool di output;
 *  2. preleva e ritorna un hash estratto dalla pool r
 */
static ssize_t extract_entropy(struct entropy_store *r, void *buf,
				 size_t nbytes, int min, int reserved)
{
	ssize_t ret = 0, i;
	__u8 tmp[EXTRACT_SIZE];
	unsigned long flags;

	/* if last_data isn't primed, we need EXTRACT_SIZE extra bytes */
	/*
	 * spento
	 */
	if (fips_enabled) {
		spin_lock_irqsave(&r->lock, flags);
		if (!r->last_data_init) {
			r->last_data_init = 1;
			spin_unlock_irqrestore(&r->lock, flags);
			trace_extract_entropy(r->name, EXTRACT_SIZE,
					      ENTROPY_BITS(r), _RET_IP_);
			xfer_secondary_pool(r, EXTRACT_SIZE);
			extract_buf(r, tmp);
			spin_lock_irqsave(&r->lock, flags);
			memcpy(r->last_data, tmp, EXTRACT_SIZE);
		}
		spin_unlock_irqrestore(&r->lock, flags);
	}
	//tralascia
	trace_extract_entropy(r->name, nbytes, ENTROPY_BITS(r), _RET_IP_);

	/*
	 * Aggiunge entropia dalla pool primaria alla pool secondaria r,
	 * per un ammontare POSSIBILMENTE pari a nbytes
	 */
	xfer_secondary_pool(r, nbytes);
	/*
	 * nbytes diviene il numero di bytes prelevabili preservando la quantità di entropia minima tollerata nella pool (reserved).
	 * min è la quantità minima di entropia
	 * prelevabile (se inferiore a min, il valore di bytes di ritorno è zero)
	 * reserved è il numero di bytes di entropia che occorre lasciare nela pool
	 *
	 * L'entropy count della pool è aggiornato!
	 */
	nbytes = account(r, nbytes, min, reserved);
	/*
	 * riempie il buffer di ritorno con i valori della pool estratti con extract_buf
	 */
	while (nbytes) {
		/*
		 * estrae un hash a partire dalla pool, lo inserisce in tmp
		 */
		extract_buf(r, tmp);

		// spento
		if (fips_enabled) {
			spin_lock_irqsave(&r->lock, flags);
			if (!memcmp(tmp, r->last_data, EXTRACT_SIZE))
				panic("Hardware RNG duplicated output!\n");
			memcpy(r->last_data, tmp, EXTRACT_SIZE);
			spin_unlock_irqrestore(&r->lock, flags);
		}
		/*
		 * copia i bytes del buffer estratto con extract_buf in buf,
		 * dieci bytes per volta
		 */
		i = min_t(int, nbytes, EXTRACT_SIZE);
		memcpy(buf, tmp, i);
		nbytes -= i;
		buf += i;
		ret += i;
	}

	/* Wipe data just returned from memory */
	memset(tmp, 0, sizeof(tmp));

	return ret;
}

/*
 * È l'equivalente di extract entropy per device file.
 * Mentre extract_entropy vene usata su input_pool solo in _xfer_secondary_pool
 * e su nonblocking_pool in tutti gli altri casi (compresa la funzione get_random_bytes che è
 * l'unico simbolo esposto verso il kernel), extract_entropy_user è la funzione utilizzata
 * dalle funzioni random_read e urandom_read esposte verso lo spazio utente e quindi viene
 * chiamata rispettivamente sulla blocking_pool che sulla nonblocking_pool.
 * Notiamo che solo lo spazio utente può prelevare bytes randomici provenienti dalla
 * blocking_pool (via /dev/random)
 *
 * Procede attraverso gli stessi passi di extract_entropy:
 * 	1. Trasferisce dalla pool primaria (possibilmente) nbytes e li mischia alla
 *     pool secondaria;
 *  2. preleva e ritorna un hash estratto dalla pool r
 */
static ssize_t extract_entropy_user(struct entropy_store *r, void __user *buf,
				    size_t nbytes)
{
	ssize_t ret = 0, i;
	/*
	 * si prepara come sempre un buffer per l'estrazione di randomicità di 10 bytes
	 * __u8 è un typedef a unsigned char
	 */
	__u8 tmp[EXTRACT_SIZE];

	//tralascia
	trace_extract_entropy_user(r->name, nbytes, ENTROPY_BITS(r), _RET_IP_);
	/*
	 * trasferisce entropia dalla pool primaria
	 * aggiorna nbytes tramite la chiamata a account
	 */
	xfer_secondary_pool(r, nbytes);
	/*
	 * nbytes diviene il numero di bytes prelevabili preservando la quantità di entropia minima tollerata nella pool (reserved).
	 * min è la quantità minima di entropia
	 * prelevabile (se inferiore a min, il valore di bytes di ritorno è zero)
	 * reserved è il numero di bytes di entropia che occorre lasciare nela pool
	 *
	 * L'entropy count della pool viene aggiornato!
	 */
	nbytes = account(r, nbytes, 0, 0);


	while (nbytes) {
		/*
		 * controllo: il processo è stato sospeso e sta riprendendo la sua esecuzione?
		 */
		if (need_resched()) {
			if (signal_pending(current)) {
				if (ret == 0)
					ret = -ERESTARTSYS;
				break;
			}
			schedule();
		}

		/*
		 * preleva il buffer dalla pool (blocking)
		 */
		extract_buf(r, tmp);

		i = min_t(int, nbytes, EXTRACT_SIZE);

		/*
		 * copia nello spazio utente
		 */
		if (copy_to_user(buf, tmp, i)) {
			ret = -EFAULT;
			break;
		}

		/*
		 * aggiorna i contatori
		 */
		nbytes -= i;
		buf += i;
		ret += i;
	}

	/* Wipe data just returned from memory */
	memset(tmp, 0, sizeof(tmp));

	return ret;
}

/*
 * This function is the exported kernel interface.  It returns some
 * number of good random numbers, suitable for key generation, seeding
 * TCP sequence numbers, etc.  It does not use the hw random number
 * generator, if available; use get_random_bytes_arch() for that.
 */

/* L'interfaccia kernel principale per l'estrazione di entropia.
 * La routine esegue solo trace_get_random_bytes e extract entropy
 * sulla nonblocking_pool.
 */

void get_random_bytes(void *buf, int nbytes)
{
/*
 * L'if viene eseguito solo se attivo lo switch
 * per il debug di random e solo quando la pool
 * nonblocking non è ancora stata inizializzata.
 */

#if DEBUG_RANDOM_BOOT > 0
	if (unlikely(nonblocking_pool.initialized == 0))
		printk(KERN_NOTICE "random: %pF get_random_bytes called "
		       "with %d bits of entropy available\n",
		       (void *) _RET_IP_,
		       nonblocking_pool.entropy_total);
#endif
	trace_get_random_bytes(nbytes, _RET_IP_);
	extract_entropy(&nonblocking_pool, buf, nbytes, 0, 0);
}
EXPORT_SYMBOL(get_random_bytes);

/*
 * This function will use the architecture-specific hardware random
 * number generator if it is available.  The arch-specific hw RNG will
 * almost certainly be faster than what we can do in software, but it
 * is impossible to verify that it is implemented securely (as
 * opposed, to, say, the AES encryption of a sequence number using a
 * key known by the NSA).  So it's useful if we need the speed, but
 * only if we're willing to trust the hardware manufacturer not to
 * have put in a back door.
 */

void get_random_bytes_arch(void *buf, int nbytes)
{
	char *p = buf;
	//tralascia
	trace_get_random_bytes_arch(nbytes, _RET_IP_);
	/*
	 * copia in buf un buffer estratto dal generatore hw di entropia
	 */
	while (nbytes) {
		unsigned long v;
		int chunk = min(nbytes, (int)sizeof(unsigned long));

		if (!arch_get_random_long(&v))
			break;
		
		memcpy(p, &v, chunk);
		p += chunk;
		nbytes -= chunk;
	}
	/*
	 * Se non sono stati prelevati tutti gli nbytes viene estratto
	 * il buffer in modo canonico.
	 */
	if (nbytes)
		extract_entropy(&nonblocking_pool, p, nbytes, 0, 0);
}
EXPORT_SYMBOL(get_random_bytes_arch);


/*
 * init_std_data - initialize pool with system data
 *
 * @r: pool to initialize
 *
 * This function clears the pool's entropy count and mixes some system
 * data into the pool to prepare it for use. The pool is not cleared
 * as that can only decrease the entropy in the pool.
 */
/*
 * Inizializza la pool r con alcuni dati di sistema (l'ora, eventualmente
 * un hash tratto da un generatore hardware di numeri pseudocasuali se
 * presente e l'hostname ust)
 * L'entropy count non viene modificato (quindi resta 0).
 */
static void init_std_data(struct entropy_store *r)
{
	int i;
	/*
	 * ottiene l'ora (vera) attuale in un formato ktine_t (sarà un equivalente di time_t)
	 */
	ktime_t now = ktime_get_real();
	unsigned long rv;

	/*
	* last_pulled è aggiornato ai jiffies attuali
	*/
	r->last_pulled = jiffies;
	/*
	 * mischia now con la pool
	 */
	mix_pool_bytes(r, &now, sizeof(now), NULL);
	/*
	 * per ogni byte di poolinfo, mischia un nuovo long prelevato
	 * dal generatore random specifico per l'architettura,
	 * oppure pari al numero di cycles se il generatore
	 * specifico non esiste.
	 */
	for (i = r->poolinfo->poolbytes; i > 0; i -= sizeof(rv)) {
		if (!arch_get_random_long(&rv))
			rv = random_get_entropy();
		mix_pool_bytes(r, &rv, sizeof(rv), NULL);
	}
	/*
	 * ustname è il nome dell'host
	 */
	mix_pool_bytes(r, utsname(), sizeof(*(utsname())), NULL);
}

/*
 * Note that setup_arch() may call add_device_randomness()
 * long before we get here. This allows seeding of the pools
 * with some platform dependent data very early in the boot
 * process. But it limits our options here. We must use
 * statically allocated structures that already have all
 * initializations complete at compile time. We should also
 * take care not to overwrite the precious per platform data
 * we were given.
 */
/*
 * Inizializza le tre pool con l'apposita funzione.
 */
static int rand_initialize(void)
{
	init_std_data(&input_pool);
	init_std_data(&blocking_pool);
	init_std_data(&nonblocking_pool);
	return 0;
}
early_initcall(rand_initialize);

#ifdef CONFIG_BLOCK
void rand_initialize_disk(struct gendisk *disk)
{
	struct timer_rand_state *state;

	/*
	 * If kzalloc returns null, we just won't use that entropy
	 * source.
	 */
	state = kzalloc(sizeof(struct timer_rand_state), GFP_KERNEL);
	if (state) {
		state->last_time = INITIAL_JIFFIES;
		disk->random = state;
	}
}
#endif


/*
 * È la funzione chiamata dall'operazione read sul device file /dev/random.
 */
static ssize_t
random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
{
	ssize_t n, retval = 0, count = 0;

	if (nbytes == 0)
		return 0;

	while (nbytes > 0) {
		n = nbytes;
		/*
		 * il numero di bytes prelevabili per volta è pari alla soglia definita dalla macro
		 */
		if (n > SEC_XFER_SIZE)
			n = SEC_XFER_SIZE;

		/*
		 * estrae i bytes di entropia per l'utente
		 *
		 * al termine della chiamata n contiene il numero effettivo di bytes di entropia prelevati nel buffer
		 * per n negativo e se non sono stati prelevati bytes buoni, viene ritornato il codice d'errore
		 *
		 * Notare la differenza del comportamento di extract_entropy_user
		 * a seconda della pool su cui viene chiamata.
		 */
		n = extract_entropy_user(&blocking_pool, buf, n);


		if (n < 0) {
			retval = n;
			break;
		}

		//tralascia
		trace_random_read(n*8, (nbytes-n)*8,
				  ENTROPY_BITS(&blocking_pool),
				  ENTROPY_BITS(&input_pool));

		if (n == 0) {
			/*
			 * se non vi sono bytes di entropia e tra i flag di file c'è nonblock,
			 * ritorna il codice di errore "riprova"
			 *
			 * Nota: O_NONBLOCK è device specific per random - urandom e i commenti
			 * al codice consigliano di mantenera attivo il flag
			 * per evitare l'effetto di "riavvolgimento del nastro" tra accessi successivi.
			 * In particolare, se attivo, una read che non ottiene alcun byte di entropia
			 * non viene bloccata dal kernel e l'invocazione di una nuova read viene gestita
			 * interamente nello spazio utente una volta che la prima ha restituito il
			 * codice d'errore EAGAIN; se inattivo, il processo chiamante è sospeso
			 * e rischedulato al sopraggiungere di entropia sufficiente.
			 *
			 * ***
			 */
			if (file->f_flags & O_NONBLOCK) {
				retval = -EAGAIN;
				break;
			}

			/*
			 * il codice di seguito è eseguito se non è stato possibile prelevare byte entropici e
			 * la lettura del file è bloccante.
			 *
			 * In tal caso, la lettura del device file è bloccata in attesa che venga segnalato il nuovo superamento della
			 * soglia di wakeup da parte della input pool.
			 */
			wait_event_interruptible(random_read_wait,
				ENTROPY_BITS(&input_pool) >=
				random_read_wakeup_thresh);

			/*
			 * Se il processo è stato risvegliato da un segnale, invia il codice di errore ERESTARTSYS,
			 * ovvero segnala al processo che è "sleeping" sulla read di random che può reinvocare
			 * la chiamata di sistema.
			 */
			if (signal_pending(current)) {
				retval = -ERESTARTSYS;
				break;
			}

			continue;
		}

		/*
		 * aggiorna i contatori
		 */
		count += n;
		buf += n;
		nbytes -= n;
		break;		/* This break makes the device work */
				/* like a named pipe */
	}
	/*
	 * se è stato prelevato almeno un byte di entropia, allora ritorna il numero di bytes relevati,
	 * altrimenti ritorna retval, che dovrebbe contenere un qualche codice d'errore (il valore negativo di n ritornato
	 * dalla chiamata a extract_entropy_user
	 */
	return (count ? count : retval);
}


/*
 * chiamata a /dev/urandom
 */
static ssize_t
urandom_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
{
	int ret;

	if (unlikely(nonblocking_pool.initialized == 0))
		printk_once(KERN_NOTICE "random: %s urandom read "
			    "with %d bits of entropy available\n",
			    current->comm, nonblocking_pool.entropy_total);

	/*
	 * estrae il buffer di entropia in modalità device file
	 */
	ret = extract_entropy_user(&nonblocking_pool, buf, nbytes);

	//tralascia
	trace_urandom_read(8 * nbytes, ENTROPY_BITS(&nonblocking_pool),
			   ENTROPY_BITS(&input_pool));
	//ritorna il numero di bytes estratti
	return ret;
}


/*
 * costruisce la maschera di poll.h per /dev/random
 */
static unsigned int
random_poll(struct file *file, poll_table * wait)
{
	unsigned int mask;

	/*
	 * le funzioni di poll.h servono per controllare se i file descriptor
	 * che corrispondono a file che sono pronti per le operazioni di IO.
	 * poll_wait iscrive random_poll presso le liste random_read_wait e random_write_wait,
	 * perché venga richiamata ogni volta che viene inviato il segnale di
	 *
	 * POLLIN: ci sono dati da leggere
	 * POLLRDNORM: come POLLIN
	 * POLLOUT: le write non sono più bloccanti
	 * POLLWRNORM: come POLLOUT
	 */
	poll_wait(file, &random_read_wait, wait);
	poll_wait(file, &random_write_wait, wait);
	mask = 0;

	if (ENTROPY_BITS(&input_pool) >= random_read_wakeup_thresh)
		mask |= POLLIN | POLLRDNORM;
	if (ENTROPY_BITS(&input_pool) < random_write_wakeup_thresh)
		mask |= POLLOUT | POLLWRNORM;
	return mask;
}

/*
 * Mischia il buffer (proveniente dallo spazio utente) con la pool prelevandone
 * e mischiando con la pool ciclicamente 16 bytes
 * Ritorna zero se tutto va a buon fine,
 */
static int
write_pool(struct entropy_store *r, const char __user *buffer, size_t count)
{
	size_t bytes;
	__u32 buf[16];
	/*
	 * user è una define nulla (define __user), serve a dichiarare la provenienza dei dati
	 * il buffer buffer (e quindi anche p) provengono dallo user_space
	 */
	const char __user *p = buffer;

	/*
	 * preleva al più 16 interi per volta dal buffer che proviene dallo spazio utente e li mischia
	 * con la pool
	 *
	 *	se la copia non riesce, ritorna un bad_address error
	 */
	while (count > 0) {
		bytes = min(count, sizeof(buf));
		if (copy_from_user(&buf, p, bytes))
			return -EFAULT;

		count -= bytes;
		p += bytes;

		mix_pool_bytes(r, buf, bytes, NULL);
		// riduce la latenza
		cond_resched();
	}

	return 0;
}

/*
 * dato un buffer in ingresso (buffer) proveniente dallo spazio utente,
 * la funzione lo mischia con la blocking_pool e con la nonblocking_pool.
 * Lo stato interno può essere modificato dallo spazio utente SOLO nelle
 * componenti addette all'output (le pool secondarie). Lo stato interno della
 * input_pool viene aggiornato invece solo dagli entropy_input e dai trasferimenti
 * di entropia verso le pool secondarie.
 */
static ssize_t random_write(struct file *file, const char __user *buffer,
			    size_t count, loff_t *ppos)
{
	size_t ret;
	/*
	 * la funzione prova a scrivere lo stesso buffer
	 * (perché lo stesso su entrambe?) su entrambe le pool
	 * secondarie.
	 *
	 * In caso di successo ritorna il numero di bytes immessi, altrimenti
	 * ritorna un bad_address (che proveniva da write_pool)
	 *
	 * Nell'ordine, non è possibile immettere i valori nella pool nonblocking
	 * senza che lo stesso buffer sia stato aggiunto alla pool blocking
	 */
	ret = write_pool(&blocking_pool, buffer, count);
	if (ret)
		return ret;
	ret = write_pool(&nonblocking_pool, buffer, count);
	if (ret)
		return ret;

	return (ssize_t)count;
}



static long random_ioctl(struct file *f, unsigned int cmd, unsigned long arg)
{
	/*
	 * ent_count contiene il numero di bits interi
	 * della pool
	 */
	int size, ent_count;
	/*
	 * p è l'indirizzo dello user space su cui scrivere
	 */
	int __user *p = (int __user *)arg;
	int retval;

	switch (cmd) {
	case RNDGETENTCNT:

		/*
		 * GET THE ENTROPY COUNT
		 * veloce, non ci sono punti bloccanti
		 */
		/* inherently racy, no point locking */
		/*
		 * se tutto va bene, la funzione scrive ent_count
		 * nello spazio utente all'indirizzo dello spazio utente
		 * putato da p
		 */
		ent_count = ENTROPY_BITS(&input_pool);
		if (put_user(ent_count, p))
			return -EFAULT;
		return 0;
	case RNDADDTOENTCNT:
		/*
		 * Add to (or subtract from) the entropy count.  (Superuser only.)
		 *
		 * Ottiene dallo spazio utente il valore di entropy_count e
		 * lo aggiunge alla input pool (funzione safe)
		 */
		if (!capable(CAP_SYS_ADMIN))
			return -EPERM;
		if (get_user(ent_count, p))
			return -EFAULT;
		credit_entropy_bits_safe(&input_pool, ent_count);
		return 0;
	case RNDADDENTROPY:
		/*
		 * Write bytes into the entropy pool and add to the entropy count.
		 * (Superuser only.)
		 *
		 * Il buffer puntato da p contiene come primo byte l'ent_count
		 * (quindi l'entropy count della pool considerando solo valori di bit interi),
		 * e come secondo byte quello qui chiamato size.
		 *
		 * Size costituisce il valore da mischiare alla pool.
		 */
		if (!capable(CAP_SYS_ADMIN))
			return -EPERM;
		if (get_user(ent_count, p++))
			return -EFAULT;
		if (ent_count < 0)
			return -EINVAL;
		if (get_user(size, p++))
			return -EFAULT;
		retval = write_pool(&input_pool, (const char __user *)p,
				    size);
		if (retval < 0)
			return retval;
		credit_entropy_bits_safe(&input_pool, ent_count);
		return 0;
	case RNDZAPENTCNT:/* Clear entropy count to 0.  (Superuser only.) */
	case RNDCLEARPOOL:
		/* Clear the entropy pool and associated counters.  (Superuser only.) */

		/*
		 * Clear the entropy pool counters. We no longer clear
		 * the entropy pool, as that's silly.
		 */
		if (!capable(CAP_SYS_ADMIN))
			return -EPERM;
		input_pool.entropy_count = 0;
		nonblocking_pool.entropy_count = 0;
		blocking_pool.entropy_count = 0;
		return 0;
	default:
		return -EINVAL;
	}
}

/* Non ho capito a cosa faccia riferimento fasync */
static int random_fasync(int fd, struct file *filp, int on)
{
	return fasync_helper(fd, filp, on, &fasync);
}

/* le operazioni per /dev/random */
const struct file_operations random_fops = {
	.read  = random_read,
	.write = random_write,
	.poll  = random_poll,
	.unlocked_ioctl = random_ioctl,
	.fasync = random_fasync,
	.llseek = noop_llseek,
};

/* le operazioni per /dev/urandom */
const struct file_operations urandom_fops = {
	.read  = urandom_read,
	.write = random_write,
	.unlocked_ioctl = random_ioctl,
	.fasync = random_fasync,
	.llseek = noop_llseek,
};

/***************************************************************
 * Random UUID interface
 *
 * Used here for a Boot ID, but can be useful for other kernel
 * drivers.
 ***************************************************************/

/*
 * Generate random UUID
 */
void generate_random_uuid(unsigned char uuid_out[16])
{
	get_random_bytes(uuid_out, 16);
	/* Set UUID version to 4 --- truly random generation */
	uuid_out[6] = (uuid_out[6] & 0x0F) | 0x40;
	/* Set the UUID variant to DCE */
	uuid_out[8] = (uuid_out[8] & 0x3F) | 0x80;
}
EXPORT_SYMBOL(generate_random_uuid);

/********************************************************************
 *
 * Sysctl interface
 *
 ********************************************************************/

#ifdef CONFIG_SYSCTL

#include <linux/sysctl.h>

static int min_read_thresh = 8, min_write_thresh;
static int max_read_thresh = INPUT_POOL_WORDS * 32;
static int max_write_thresh = INPUT_POOL_WORDS * 32;
static char sysctl_bootid[16];

/*
 * These functions is used to return both the bootid UUID, and random
 * UUID.  The difference is in whether table->data is NULL; if it is,
 * then a new UUID is generated and returned to the user.
 *
 * If the user accesses this via the proc interface, it will be returned
 * as an ASCII string in the standard UUID format.  If accesses via the
 * sysctl system call, it is returned as 16 bytes of binary data.
 */
static int proc_do_uuid(struct ctl_table *table, int write,
			void __user *buffer, size_t *lenp, loff_t *ppos)
{
	struct ctl_table fake_table;
	unsigned char buf[64], tmp_uuid[16], *uuid;

	uuid = table->data;
	if (!uuid) {
		uuid = tmp_uuid;
		generate_random_uuid(uuid);
	} else {
		static DEFINE_SPINLOCK(bootid_spinlock);

		spin_lock(&bootid_spinlock);
		if (!uuid[8])
			generate_random_uuid(uuid);
		spin_unlock(&bootid_spinlock);
	}

	sprintf(buf, "%pU", uuid);

	fake_table.data = buf;
	fake_table.maxlen = sizeof(buf);

	return proc_dostring(&fake_table, write, buffer, lenp, ppos);
}

/*
 * Return entropy available scaled to integral bits
 */
static int proc_do_entropy(ctl_table *table, int write,
			   void __user *buffer, size_t *lenp, loff_t *ppos)
{
	ctl_table fake_table;
	int entropy_count;

	entropy_count = *(int *)table->data >> ENTROPY_SHIFT;

	fake_table.data = &entropy_count;
	fake_table.maxlen = sizeof(entropy_count);

	return proc_dointvec(&fake_table, write, buffer, lenp, ppos);
}

static int sysctl_poolsize = INPUT_POOL_WORDS * 32;
extern struct ctl_table random_table[];
struct ctl_table random_table[] = {
	{
		.procname	= "poolsize",
		.data		= &sysctl_poolsize,
		.maxlen		= sizeof(int),
		.mode		= 0444,
		.proc_handler	= proc_dointvec,
	},
	{
		.procname	= "entropy_avail",
		.maxlen		= sizeof(int),
		.mode		= 0444,
		.proc_handler	= proc_do_entropy,
		.data		= &input_pool.entropy_count,
	},
	{
		.procname	= "read_wakeup_threshold",
		.data		= &random_read_wakeup_thresh,
		.maxlen		= sizeof(int),
		.mode		= 0644,
		.proc_handler	= proc_dointvec_minmax,
		.extra1		= &min_read_thresh,
		.extra2		= &max_read_thresh,
	},
	{
		.procname	= "write_wakeup_threshold",
		.data		= &random_write_wakeup_thresh,
		.maxlen		= sizeof(int),
		.mode		= 0644,
		.proc_handler	= proc_dointvec_minmax,
		.extra1		= &min_write_thresh,
		.extra2		= &max_write_thresh,
	},
	{
		.procname	= "urandom_min_reseed_secs",
		.data		= &random_min_urandom_seed,
		.maxlen		= sizeof(int),
		.mode		= 0644,
		.proc_handler	= proc_dointvec,
	},
	{
		.procname	= "boot_id",
		.data		= &sysctl_bootid,
		.maxlen		= 16,
		.mode		= 0444,
		.proc_handler	= proc_do_uuid,
	},
	{
		.procname	= "uuid",
		.maxlen		= 16,
		.mode		= 0444,
		.proc_handler	= proc_do_uuid,
	},
	{ }
};
#endif 	/* CONFIG_SYSCTL */

static u32 random_int_secret[MD5_MESSAGE_BYTES / 4] ____cacheline_aligned;

int random_int_secret_init(void)
{
	get_random_bytes(random_int_secret, sizeof(random_int_secret));
	return 0;
}

/*
 * Get a random word for internal kernel use only. Similar to urandom but
 * with the goal of minimal entropy pool depletion. As a result, the random
 * value is not cryptographically secure but for several uses the cost of
 * depleting entropy is too high
 */
static DEFINE_PER_CPU(__u32 [MD5_DIGEST_WORDS], get_random_int_hash);
unsigned int get_random_int(void)
{
	__u32 *hash;
	unsigned int ret;

	if (arch_get_random_int(&ret))
		return ret;

	hash = get_cpu_var(get_random_int_hash);

	hash[0] += current->pid + jiffies + random_get_entropy();
	md5_transform(hash, random_int_secret);
	ret = hash[0];
	put_cpu_var(get_random_int_hash);

	return ret;
}
EXPORT_SYMBOL(get_random_int);

/*
 * randomize_range() returns a start address such that
 *
 *    [...... <range> .....]
 *  start                  end
 *
 * a <range> with size "len" starting at the return value is inside in the
 * area defined by [start, end], but is otherwise randomized.
 */
unsigned long
randomize_range(unsigned long start, unsigned long end, unsigned long len)
{
	unsigned long range = end - len - start;

	if (end <= start + len)
		return 0;
	return PAGE_ALIGN(get_random_int() % range + start);
}
